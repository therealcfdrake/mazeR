---
title: "Untitled"
output: html_document
date: "2023-04-22"
---
```{r}

library(tidyverse)

# Append List
lappend <-
  function (lst, ...){ # function borrowed from stack
    lst <- c(lst, list(...))
  return(lst)
}

is.odd <- function(x){
  x %% 2 == 1
}

is.even <- function(x){
  x %% 2 == 0
}

# function to implement curl (rotational bias)
curler2 <-
  function(base_weights, curl, curl_weight){
    n_dir <- length(base_weights)
    pmax(base_weights + 
         cos(curl * pi - seq(-pi, pi, length.out = n_dir + 1)[-1]) * 
         curl_weight * 
         !equals(base_weights, 0L),
         0)
  }

#' Generate Maze Object
#'
#' @param w_maze width of maze
#' @param l_maze length of maze
#' @param exit `c(w, l)` coordinates of exit
#' @param i_weight a positive weight given to random directions in the i direction
#' @param j_weight a positive weight given to random directions in the j direction
#' @param curl a real on the interval `[-1, 1]` with negative values favoring clockwise
#' turns and positive values favoring counterclockwise turns. a curl of 0 favors continuing
#' in a straight line.
#' @param curl_weight a positive weight given to curl related
#' @param curl_prob a numeric value describing the probability that curl is applied. Once applied, curl
#'  will influence subsequent direction choices until the algorithm reaches a dead end.
#' @param uncurl a logical which causes the direction of curl to alternate each time it resets
#' @param progress a logical which triggers an update to print each time 1000 cells have been visited
#' @param seed a real value which can be passed as a seed to reproduce a maze
#' @param ... other parameters
#' @examples
#' library(tidyverse)
#' generate_maze()
#' @export
#' @import tidyr
#' @import magrittr
#' @import bmp
#' @returns a Maze object

generate_maze_tri <-
  function(w_maze = 5,
           l_maze = 10,
           exit = c(w_maze, l_maze),
           i_weight = 1,
           j_weight = 1,
           curl = 0,
           curl_weight = 0,
           curl_prob = 0,
           uncurl = FALSE,
           progress = FALSE,
           seed = NULL, ...){

  # set seed, if provided
  if(!is.null(seed)){set.seed(seed)}

  # define exit, if not provided
  if(is.null(exit)){exit <- c(sample(1:w_maze, 1), sample(1:l_maze, 1))}

  # initialize variables
  n_cells <- w_maze * l_maze
  maze_array <-
    array(c(rep(outer(1:w_maze,1:l_maze-1,"+")%%2, 3),
            rep(0L, n_cells)),
          dim = c(w_maze, l_maze, 4))
  available_set <- c(1L, 2L, 3L, 4L, 5L, 6L)
  apply_curl <- FALSE
  last_dir <- 0L
  path <- list()
  i <- 1
  j <- 1
  k <- 1

  cell_counter <- 0

  # find path through all cells
  while(cell_counter < n_cells){

    # print update status every 10000 cells if `progress` is set
    if(cell_counter %% 1000 == 0 & progress){print(cell_counter)}

    # list of coordinates from start to current position
    path <- lappend(path, c(i, j))

    # save solution if you've reached the end
    if(all(c(i, j) == exit)){solution <- path}

    cell_counter <- cell_counter + 1

    # mark current cell as "visited"
    maze_array[i, j, 4] <- 1L

    # stop if all cells have been visited
    if(cell_counter == n_cells){break}

    ###########################
    ###  RNG-direction map  ###
    ###########################
    #   1     <->    +i       #
    # 5 4 2 3 <-> -j -k +j +k #
    #   6     <->    -i       #
    ###########################

    # initialize vector containing probabilities of moving in each direction
    move_probs <- rep(0L, 6)

    # update probabilities
    while(sum(move_probs) == 0L){

      if(i < w_maze){if(maze_array[i + 1, j, 4] != 1L && is.odd(i + j)){move_probs[1] <- i_weight}}
      if(j < l_maze){if(maze_array[i, j + 1, 4] != 1L){move_probs[2] <- j_weight}}
      if(i > 1L)    {if(maze_array[i - 1, j, 4] != 1L && is.even(i + j)){move_probs[6] <- i_weight}}
      if(j > 1L)    {if(maze_array[i, j - 1, 4] != 1L){move_probs[5] <- j_weight}}

      if(!apply_curl){apply_curl <-  rbinom(1, 1, curl_prob) == 1}

      if(apply_curl){
        if(last_dir == 1L){
          move_probs[c(5, 2, 6)] <- curler2(move_probs[c(5, 2, 6)], curl, curl_weight)
        }
        if(last_dir == 2L && is.odd(i + j)){
          move_probs[c(1, 2, 5)] <- curler2(move_probs[c(1, 2, 5)], curl, curl_weight)
        }
        if(last_dir == 2L && is.even(i + j)){
          move_probs[c(6, 2, 5)] <- curler2(move_probs[c(6, 2, 5)], curl, curl_weight)
        }
        if(last_dir == 6L){
          move_probs[c(2, 5, 1)] <- curler2(move_probs[c(2, 5, 1)], curl, curl_weight)
        }
        if(last_dir == 5L && is.odd(i + j)){
          move_probs[c(6, 5, 2)] <- curler2(move_probs[c(6, 5, 2)], curl, curl_weight)
        }
        if(last_dir == 5L && is.even(i + j)){
          move_probs[c(5, 1, 2)] <- curler2(move_probs[c(5, 1, 2)], curl, curl_weight)
        }
      }

      # backtrack if no paths forward are available
      if(sum(move_probs) == 0L){
        path <- head(path, -1)
        tmp <- tail(path, 1)[[1]]
        apply_curl <- FALSE
        last_dir <- 0L
        i <- tmp[1]
        j <- tmp[2]
        if(uncurl){curl <- -curl}
      }

    }

    # choose direction of next move
    next_dir <- sample(available_set, 1, prob = move_probs)

    i2 <- i
    j2 <- j

    if(next_dir == 1L){i2 <- i + 1}
    if(next_dir == 2L){j2 <- j + 1}
    if(next_dir == 5L){j2 <- j - 1}
    if(next_dir == 6L){i2 <- i - 1}

    if(next_dir == 1L && is.even(i + j)){maze_array[i, j, 1] <- 0L}
    if(next_dir == 1L && is.odd(i + j)){maze_array[i + 1, j, 1] <- 0L}
    if(next_dir == 6L && is.even(i + j)){maze_array[i, j, 1] <- 0L}
    if(next_dir == 6L && is.odd(i + j)){maze_array[i - 1, j, 1] <- 0L}
    if(next_dir == 2L && is.even(i + j)){maze_array[i, j, 2] <- 0L}
    if(next_dir == 2L && is.odd(i + j)){maze_array[i, j + 1, 3] <- 0L}
    if(next_dir == 5L && is.even(i + j)){maze_array[i, j, 3] <- 0L}
    if(next_dir == 5L && is.odd(i + j)){maze_array[i, j - 1, 2] <- 0L}


    i <- i2
    j <- j2
    last_dir <- next_dir

  }

  # create Maze S4 object
  new("Maze",
      width = w_maze,
      length = l_maze,
      height = 1,
      array = maze_array,
      exit = exit,
      solution = solution,
      tile = "square")
}



```

```{r}

#' Render a Maze object
#'
#' @param maze a Maze object
#' @param show_solution a logical describing whether to plot the solution to the maze
#' @examples
#' library(tidyverse)
#' generate_maze()
#' @export
#' @import ggplot2
#' @import dplyr
#' @import stringr
#' @importFrom lemon facet_rep_wrap
#' @returns ggplot of Maze object
 

render_maze_tri <-
  function(maze, show_solution = FALSE){

  w_maze <- maze@width
  l_maze <- maze@length
  h_maze <- maze@height
  maze_array <- maze@array
  exit <- maze@exit
  solution <- maze@solution

  # initialize solution df
  plotdata_solution <-
    data.frame(y = c(1, 1), x = c(1, 1), id = c(0, 0))

  # build solution df
  if(show_solution) {
    plotdata_solution <-
      solution %>%
      unlist %>%
      matrix(ncol = 2,
             byrow = TRUE,
             dimnames = list(NULL, c("y", "x"))
             ) %>%
      data.frame() %>%
      mutate(across(c(x, y), ~(.x + lag(.x, default = 0)) / 2)) %>% 
      mutate(id = row_number())
  }

  # length of solution path
  n_sol_path <-
    pull(plotdata_solution) %>%
    unique %>%
    length

  # initialize maze walls list with borders
  wallslist <-
    list(data.frame(id = rep("edge", 2 * w_maze + 3),
                    x = c(l_maze - is.even(l_maze), # bottom right
                          0, # bottom left
                          as.integer(is.odd(1:w_maze)), # zigzag left
                          l_maze + as.integer(is.odd(l_maze + w_maze:0))), # zigzag right
                    y = c(0.5, 
                          0.5, 
                          0.5 + 1:w_maze, 
                          0.5 + w_maze:1,
                          0.5)))

  ##### extract coordinates for northern walls

    for(i in 1:w_maze){
      for(j in 1:l_maze){
        if(maze_array[i, j, 1] == 1L){
          wallslist <-
            lappend(wallslist,
                    data.frame(id = rep(paste0("i", str_pad(i, width = nchar(w_maze), side = "left", pad = "0"), str_pad(j, width = nchar(l_maze), side = "left", pad = "0")), 2),
                               x = c(j - 1, j + 1),
                               y = c(i - 0.5, i - 0.5))
                    )
        }
      }
    }

  ##### extract coordinates for eastern walls

    for(i in 1:w_maze){
      for(j in 1:l_maze){
        if(maze_array[i, j, 2] == 1L){
          wallslist <-
            lappend(wallslist,
                    data.frame(id = rep(paste0("j", str_pad(i, width = nchar(w_maze), side = "left", pad = "0"), str_pad(j, width = nchar(l_maze), side = "left", pad = "0")), 2),
                               x = c(j, j + 1),
                               y = c(i + 0.5, i - 0.5))
                    )
        }
      }
    }

  ##### extract coordinate for ladders

  ladderlist <- list()

    for(i in 1:w_maze){
      for(j in 1:l_maze){
        if(maze_array[i, j, 3] == 1L){
          wallslist <-
            lappend(wallslist,
                    data.frame(id = rep(paste0("k", str_pad(i, width = nchar(w_maze), side = "left", pad = "0"), str_pad(j, width = nchar(l_maze), side = "left", pad = "0")), 2),
                               x = c(j, j - 1),
                               y = c(i + 0.5, i - 0.5))
                    )
        }
      }
    }

  # define start- and end-points of path
  startenddata <-
    data.frame(id = c("start", "end"),
               x = c(1, exit[2]),
               y = c(1, exit[1]),
               d = c("none", "none"))

  plotdata_walls <-
    bind_rows(wallslist)

  plotdata_points <-
    bind_rows(ladderlist) %>%
    bind_rows(startenddata)

  # create ggplot of maze

    plot_out <-
      plotdata_walls %>%
      ggplot(aes(x = x, y = y)) +
      geom_path(aes(group = id), lineend = "round", size = 0) +
      geom_path(data = plotdata_solution, aes(color = id), size = 1, lineend = "round", linejoin = "round") +
      scale_color_gradient(low = "limegreen", high = "purple4") +
      geom_point(data = plotdata_points, aes(shape = d), color = "black") +
      scale_shape_manual(values = c("u" = 2, "d" = 6, "none" = 16)) +
      scale_x_continuous(breaks = 1:l_maze) +
      scale_y_continuous(breaks = 1:w_maze) +
      coord_fixed(ratio = sqrt(3)) +
      theme(panel.background = element_rect(fill = NA),
            axis.text = element_blank(),
            axis.ticks = element_blank(),
            axis.title = element_blank(),
            legend.position = "none",
            plot.margin = unit( c(0,0,0,0), "in" ),
            axis.ticks.length = unit(0, "cm")) +
      NULL

  plot_out

  }


```


```{r}

a <- generate_maze_tri(57, 100, curl = 0.0, curl_weight = 5, uncurl = TRUE, curl_prob = 0.1)
render_maze_tri(a, show_solution = TRUE)

```
```{r}

b <- generate_maze(100, 100, j_weight = 10, mask_dir = "C:\\Users\\corie\\Desktop\\mask1.bmp")
render_maze(b)

```

```{r}

d <- generate_maze(50, 50, curl_weight = 1, curl_prob = 0.5, curl = 0.5, uncurl = F, exit = c(25, 25, 1))
# curler2(c(1, 50, 1), curl = -1, curl_weight = 20)
render_maze(d)
render_maze(d, show_solution = TRUE)


```


